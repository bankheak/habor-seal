}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
newt.occ
setwd("C:/Users/bankh/OneDrive/Documents/Homework/OSU/ST 512")
knitr::opts_chunk$set(echo = TRUE)
full.data<-read.csv("../data/full.data.csv")
# Load packages
require(ggplot2)
# Check distribution
ggplot(full.data, aes(x=seals)) +
geom_histogram(aes(y=..density..), colour="black", fill="white")+
geom_density()+stat_density(alpha=.2,adjust = 1, fill="#FF6666")+xlab("Number of Seals Hauled-out")+ylab("Density")+theme(panel.background = element_blank())
full.data<-read.csv("../data/full.data.csv")
require(performance)
var(full.data$seals)
mean(full.data$seals)
# Make sure overdispersion is detected with full model
mod<- glm(seals ~ site*noise + month + tide + time, data = full.data, family = "poisson")
check_overdispersion(mod)
# Check for zero inflation
check_zeroinflation(mod)
require(performance)
var(full.data$seals)
mean(full.data$seals)
# Make sure overdispersion is detected with full model
mod<- glm(seals ~ site*noise + month + tide + time, data = full.data, family = "poisson")
check_overdispersion(mod)
# Check for zero inflation
check_zeroinflation(mod)
require(performance) # overdispersion
require(DHARMa) # auto cor and zero-inflation
var(full.data$seals)
mean(full.data$seals)
# Check poisson model
mod<- glm(seals ~ site*noise + month + tide + time, data = full.data, family = "poisson")
simulationOutput <- simulateResiduals(fittedModel = mod)
# Check for overdispersion
check_overdispersion(mod)
# Check for zero inflation
check_zeroinflation(simulationOutput)
simulationOutput
## Negative binomial or poisson would be the best fit
mod<- glmmTMB(seals ~ noise*site + (1 | month), data = full.data,
family = nbinom2, zi = ~ 1)
require(MASS) # for glm
require(performance) # overdispersion
require(DHARMa) # auto cor and zero-inflation
var(full.data$seals)
mean(full.data$seals)
# Check poisson model
mod<- glm(seals ~ site*noise + month + tide + time, data = full.data, family = "poisson")
simulationOutput <- simulateResiduals(fittedModel = mod)
# Check for overdispersion
check_overdispersion(mod)
# Check for zero inflation
check_zeroinflation(simulationOutput)
require(glmmTMB) # for glmm
## Negative binomial or poisson would be the best fit
mod<- glmmTMB(seals ~ noise*site + (1 | month), data = full.data,
family = nbinom2, zi = ~ 1)
simulationOutput <- simulateResiduals(fittedModel = mod)
### Check if data is zero inflated
testZeroInflation(simulationOutput)
require(MASS) # for glm
require(performance) # overdispersion
require(DHARMa) # auto cor and zero-inflation
var(full.data$seals)
mean(full.data$seals)
# Check poisson model
mod<- glm(seals ~ site*noise + month + tide + time, data = full.data, family = "poisson")
simulationOutput <- simulateResiduals(fittedModel = mod)
# Check for overdispersion
check_overdispersion(mod)
# Check for zero inflation
testZeroInflation(simulationOutput)
require(glmmTMB) # for glmm
require(DHARMa) # auto cor and zero-inflation
# Check Temporal Autocorrelation
## Run acf for both direct and indirect effects
acf(full.data$seals[full.data$site == "waterfront"]) # Highly autocorrelated at lag of 1
acf(full.data$seals[full.data$site == "marina"]) # Autocorrelated at lag of 6
# Correct for autocorrelation with ar1()
fittedModel<- glmmTMB(seals ~ noise*site + tide + time + (1 | date) + ar1(as.factor(month) + 0 | year), data = full.data,
family = nbinom2, zi = ~ 1)
res = simulateResiduals(fittedModel)
testTemporalAutocorrelation(res, time = unique(full.data$obs_id))
# Load packages
require(glmmTMB) # for glmm
require(AICcmodavg) #for AICc
model0<- glmmTMB(seals ~ 1, data = full.data,
family = nbinom2, zi = ~ 1)
model1<- glmmTMB(seals ~ noise*site + tide + time + (1 | date) +
ar1(as.factor(month) + 0 | year), data =                           full.data, family = nbinom2, zi = ~ 1)
model2<- glmmTMB(seals ~ noise*site +  (1 | date) + time +
ar1(as.factor(month) + 0 | year), data =                                full.data, family = nbinom2, zi = ~ 1)
model3<- glmmTMB(seals ~ noise*site + (1 | date) +
ar1(as.factor(month) + 0 | year), data =                               full.data, family = nbinom2, zi = ~ 1)
model4<- glmmTMB(seals ~ noise+site + (1 | date) +
ar1(as.factor(month) + 0 | year), data =                               full.data, family = nbinom2, zi = ~ 1)
# Create list
models<-list(model0, model1, model2, model3, model4)
## Calculate AICc with glm of models
Modnames<- c("seals ~ 1",
"seals ~ site*noise + tide + time",
"seals ~ site*noise + time",
"seals ~ site*noise",
"seals ~ site+noise")
aictab(models, modnames = Modnames,
second.ord = TRUE,
nobs = NULL, sort = TRUE, c.hat = 1) # Looks like site*noise + month + time are the best predictors
summary(model3)
# What does the interaction between site and noise look like?
interaction.plot(x.factor = full.data$noise, #x-axis variable
trace.factor = full.data$site, #variable for lines
response = full.data$seals, #y-axis variable
fun = median, #metric to plot
ylab = "Number of Seals Hauled-out",
xlab = "Noise Level (dB)",
col = c("pink", "blue"),
lty = 1, #line type
lwd = 2, #line width
trace.label = "Site")
newdata <- data.frame(noise = mean(full.data$noise),
site = factor(1:2, levels = 1:2,
labels = unique(full.data$site)))
m3<- glm.nb(seals ~ site * noise, data = full.data)
newdata$phat <- predict.glm(m3, newdata, type = "response")
newdata
# Plot
newdata2 <- data.frame(
noise = rep(seq(from = min(full.data$noise), to = max(full.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(full.data$site)))
newdata2 <- cbind(newdata2, predict(m3, newdata2, type = "link", se.fit=TRUE))
newdata2 <- within(newdata2, {
seals <- exp(fit)
LL <- exp(fit - 1.96 * se.fit)
UL <- exp(fit + 1.96 * se.fit)
})
ggplot(newdata2, aes(noise, seals)) +
geom_ribbon(aes(ymin = LL, ymax = UL, fill = site), alpha = .25) +
geom_line(aes(colour = site), linewidth = 2) +
labs(x = "Noise Level (dB)", y = "Predicted Number of Seals Hauled-out")
knitr::opts_chunk$set(echo = TRUE)
data <- read.csv("galapagos.csv")
attach(data)
fit1 <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent)
summary(fit1)
plot(fit1$fitted, fit1$resid, xlab="Fitted Values", ylab="Residuals", pch=16)
abline(h=0)
plot(Area, fit1$resid, xlab="Area", ylab="Residuals", pch=16)
abline(h=0)
plot(Area, fit1$resid, xlab="Area", ylab="Residuals", pch=16)
abline(h=0)
which(Area>1500)
# Make Observation Column
data$Obs<- seq_along(data[,1])
# Leverage
levg<- hatvalues(fit1)
plot(Obs, levg, ylab="Leverage",xlab="Observations")
# Make Observation Column
data$Obs<- seq_along(data[,1])
attach(data)
# Leverage
levg<- hatvalues(fit1)
plot(Obs, levg, ylab="Leverage",xlab="Observations")
abline(h=0.5, lty="dashed",col="red")
which(levg>0.5)
# Cook's Distance
cooksd<- cooks.distance(fit1)
plot(Obs,cooksd, ylab="Cook distance",xlab="Observations")
abline(h=1, lty="dashed",col="red")
abline(h = 4/17, col="red")
which(cooksd>1)
# Standardized Residuals
standard_res <- rstandard(fit1)
plot(Obs,standard_res, ylab="Standardized residuals",xlab="Observations")
abline(h=0, lty="dashed") # We include line at 0 for reference
abline(h=2, lty="dashed",col="red") # We include this value for reference
abline(h=-2, lty="dashed",col="red") # We include this value for reference
which(abs((standard_res))>2)
View(data)
labelsubs <- subset(data, levg>0.4)
labelsubs
View(labelsubs)
# Make Observation Column
data$Obs<- seq_along(data[,1])
attach(data)
# Leverage  2(6)/30=0.4
levg<- hatvalues(fit1)
labelsubs <- subset(data, levg>0.4)
plot(Obs, levg, ylab="Leverage",xlab="Observations")
abline(h=0.4, lty="dashed",col="red")
text(labelsubs$X, labelsubs$Obs, row.names(labelsubs), pos=1, col="red")
which(levg>0.4)
# Cook's Distance
cooksd<- cooks.distance(fit1)
plot(Obs,cooksd, ylab="Cook distance",xlab="Observations")
abline(h=1, lty="dashed",col="red")
abline(h = 4/17, col="red")
which(cooksd>1)
# Standardized Residuals
standard_res <- rstandard(fit1)
plot(Obs,standard_res, ylab="Standardized residuals",xlab="Observations")
abline(h=0, lty="dashed") # We include line at 0 for reference
abline(h=2, lty="dashed",col="red") # We include this value for reference
abline(h=-2, lty="dashed",col="red") # We include this value for reference
which(abs((standard_res))>2)
levg<- hatvalues(fit1)
# Make Observation Column
data$Obs<- seq_along(data[,1])
attach(data)
# Leverage  2(6)/30=0.4
levg<- hatvalues(fit1)
labelsubs <- subset(data, levg>0.4)
plot(Obs, levg, ylab="Leverage",xlab="Observations")
abline(h=0.4, lty="dashed",col="red")
text(Obs, levg, row.names(labelsubs), pos=1, col="red")
which(levg>0.4)
# Cook's Distance
cooksd<- cooks.distance(fit1)
plot(Obs,cooksd, ylab="Cook distance",xlab="Observations")
abline(h=1, lty="dashed",col="red")
abline(h = 4/17, col="red")
which(cooksd>1)
# Standardized Residuals
standard_res <- rstandard(fit1)
plot(Obs,standard_res, ylab="Standardized residuals",xlab="Observations")
abline(h=0, lty="dashed") # We include line at 0 for reference
abline(h=2, lty="dashed",col="red") # We include this value for reference
abline(h=-2, lty="dashed",col="red") # We include this value for reference
which(abs((standard_res))>2)
# Make Observation Column
data$Obs<- seq_along(data[,1])
attach(data)
# Leverage  2(6)/30=0.4
levg<- hatvalues(fit1)
plot(Obs, levg, ylab="Leverage",xlab="Observations")
abline(h=0.4, lty="dashed",col="red")
which(levg>0.4)
# Cook's Distance
cooksd<- cooks.distance(fit1)
plot(Obs,cooksd, ylab="Cook distance",xlab="Observations")
abline(h=1, lty="dashed",col="red")
abline(h = 4/17, col="red")
which(cooksd>1)
# Standardized Residuals
standard_res <- rstandard(fit1)
plot(Obs,standard_res, ylab="Standardized residuals",xlab="Observations")
abline(h=0, lty="dashed") # We include line at 0 for reference
abline(h=2, lty="dashed",col="red") # We include this value for reference
abline(h=-2, lty="dashed",col="red") # We include this value for reference
which(abs((standard_res))>2)
data2<- data[-c(8, 12, 15, 16, 19, 25),]
View(data2)
length(data2)
# Remove 17
data2<- data[-c(8, 12, 15, 16, 19, 25),]
attach(data2)
fit2 <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent)
summary(fit2)
# Remove 17
data2<- data[-c(8, 12, 15, 16, 19, 25),]
attach(data2)
fit2 <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent)
summary(fit2)
View(data)
fat <- read.csv("fat.csv")
head(fat[1:10,])
knitr::opts_chunk$set(echo = TRUE)
dim(fat)
install.packages("olsrr")
fat <- read.csv("fat.csv")
# Show data
head(fat[1:10,])
# A) Dimensions of data
dim(fat)
# B) Split the data in a “training set” and a “testing set”
n <- nrow(fat)
remove.ind <- seq(10, n, by=10)
test <- fat[remove.ind, ]
train <- fat[-remove.ind, ]
full<- lm(siri ~ age + weight + height + adipos + free + neck + chest + hip + thigh + knee + ankle + biceps + forearm + wrist, data = train)
summary(full)
require(olsrr)
# A) Use help to learn more about the arguments in the function
forwardmod <- ols_step_forward_p(full, penter=0.05, progress=FALSE)
summary(forwardmod$model)
# B) Use help to learn more about the arguments in the function
backmod <- ols_step_backward_p(full, prem=0.05, progress=FALSE)
summary(backmod$model)
# C)
forwardmod
backmod
install.packages("leaps")
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC<- lm(siri ~ adipos + free + weights + forearm + chest + thigh + age, data = train)
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC<- lm(siri ~ adipos + free + weights + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC <- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.AIC)
# B)
summary(all)$which[which.min(summary(all)$bic),]
min.BIC<- lm(siri ~ adipos + free + weights + forearm + chest + thigh + age, data = train)
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC <- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.AIC)
# B)
summary(all)$which[which.min(summary(all)$bic),]
min.BIC<- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom, data = train)
summary(min.BIC)
# C)
summary(all)$which[which.min(summary(all)$cp),]
min.cp<- lm(siri ~ adipos + free + weights + forearm + chest + thigh + age, data = train)
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC <- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.AIC)
# B)
summary(all)$which[which.min(summary(all)$bic),]
min.BIC<- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom, data = train)
summary(min.BIC)
# C)
summary(all)$which[which.min(summary(all)$cp),]
min.cp<- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.cp)
truth <- test$siri
# Predict model
pred.full <- predict(full, newdata=test)
pred.all <- predict(all, newdata=test)
truth <- test$siri
# Predict model
pred.full <- predict(full, newdata=test)
pred.AIC <- predict(min.AIC, newdata=test)
pred.BIC <- predict(min.BIC, newdata=test)
pred.cp <- predict(min.cp, newdata=test)
# A) RMSE
rmse.full <- sqrt(mean((truth-pred.full)^2))
rmse.AIC <- sqrt(mean((truth-pred.AIC)^2))
rmse.BIC <- sqrt(mean((truth-pred.BIC)^2))
rmse.cp <- sqrt(mean((truth-pred.cp)^2))
truth <- test$siri
# Predict model
pred.full <- predict(full, newdata=test)
pred.AIC <- predict(min.AIC, newdata=test)
pred.BIC <- predict(min.BIC, newdata=test)
pred.cp <- predict(min.cp, newdata=test)
# A) RMSE
rmse.full <- sqrt(mean((truth-pred.full)^2))
rmse.full
rmse.AIC <- sqrt(mean((truth-pred.AIC)^2))
rmse.AIC
rmse.BIC <- sqrt(mean((truth-pred.BIC)^2))
rmse.BIC
rmse.cp <- sqrt(mean((truth-pred.cp)^2))
rmse.cp
knitr::opts_chunk$set(echo = TRUE)
fat <- read.csv("fat.csv")
# Show data
head(fat[1:10,])
# A) Dimensions of data
dim(fat)
# B) Split the data in a “training set” and a “testing set”
n <- nrow(fat)
remove.ind <- seq(10, n, by=10)
test <- fat[remove.ind, ]
train <- fat[-remove.ind, ]
full<- lm(siri ~ age + weight + height + adipos + free + neck + chest + hip + thigh + knee + ankle + biceps + forearm + wrist + abdom, data = train)
summary(full)
require(olsrr)
# A) Use help to learn more about the arguments in the function
forwardmod <- ols_step_forward_p(full, penter=0.05, progress=FALSE)
summary(forwardmod$model)
# B) Use help to learn more about the arguments in the function
backmod <- ols_step_backward_p(full, prem=0.05, progress=FALSE)
summary(backmod$model)
# C)
forward.mod
require(olsrr)
# A) Use help to learn more about the arguments in the function
forwardmod <- ols_step_forward_p(full, penter=0.05, progress=FALSE)
summary(forwardmod$model)
# B) Use help to learn more about the arguments in the function
backmod <- ols_step_backward_p(full, prem=0.05, progress=FALSE)
summary(backmod$model)
# C)
forwardmod
backmod
require(olsrr)
# A) Use help to learn more about the arguments in the function
forwardmod <- ols_step_forward_p(full, penter=0.05, progress=FALSE)
summary(forwardmod$model)
# B) Use help to learn more about the arguments in the function
backmod <- ols_step_backward_p(full, prem=0.05, progress=FALSE)
summary(backmod$model)
# C)
forward.mod <- lm(siri ~ weight + adipos + free + chest + thigh + ankle + forearm + abdom, data = train)
forward.mod
back.mod <- lm(siri ~ weight + adipos + free + chest + thigh + ankle + forearm + abdom, data = train, data = train)
require(olsrr)
# A) Use help to learn more about the arguments in the function
forwardmod <- ols_step_forward_p(full, penter=0.05, progress=FALSE)
summary(forwardmod$model)
# B) Use help to learn more about the arguments in the function
backmod <- ols_step_backward_p(full, prem=0.05, progress=FALSE)
summary(backmod$model)
# C)
forward.mod <- lm(siri ~ weight + adipos + free + chest + thigh + ankle + forearm + abdom, data = train)
forward.mod
back.mod <- lm(siri ~ weight + adipos + free + chest + thigh + ankle + forearm + abdom, data = train)
back.mod
require(leaps)
p <- ncol(train) - 3 # response, brozek, density not predictors
all <- regsubsets(siri ~ . - brozek - density, data=train, nvmax=p)
# A) T = smallest AIC
calc.AIC <- n * log(summary(all)$rss / n) + 2*(2:(p+1))
summary(all)$which[which.min(calc.AIC),]
min.AIC <- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.AIC)
# B)
summary(all)$which[which.min(summary(all)$bic),]
min.BIC<- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom, data = train)
summary(min.BIC)
# C)
summary(all)$which[which.min(summary(all)$cp),]
min.cp<- lm(siri ~ adipos + free + weight + forearm + chest + thigh + abdom + knee + ankle + biceps, data = train)
summary(min.cp)
truth <- test$siri
# Predict model
pred.full <- predict(full, newdata=test)
pred.forward.mod <- predict(forward.mod, newdata=test)
pred.back.mod <- predict(back.mod, newdata=test)
pred.AIC <- predict(min.AIC, newdata=test)
pred.BIC <- predict(min.BIC, newdata=test)
pred.cp <- predict(min.cp, newdata=test)
# A) RMSE
rmse.full <- sqrt(mean((truth-pred.full)^2))
rmse.full
rmse.for <- sqrt(mean((truth-pred.forward.mod)^2))
rmse.for
rmse.back <- sqrt(mean((truth-pred.back.mod)^2))
rmse.back
rmse.AIC <- sqrt(mean((truth-pred.AIC)^2))
rmse.AIC
rmse.BIC <- sqrt(mean((truth-pred.BIC)^2))
rmse.BIC
rmse.cp <- sqrt(mean((truth-pred.cp)^2))
rmse.cp
setwd("C:/Users/bankh/My_Repos/habor-seal/data")
# Require packages
require(ggplot2)
# Retrieve data
m.data<-read.csv("m.data.csv")
w.data<-read.csv("new.w.data.csv")
# Create organized dataset
w.data$seals<- ifelse(w.data$seals>0,w.data$seals,NA)
m.data$seals<- ifelse(m.data$seals>0,m.data$seals,NA)
w.data<- na.omit(w.data)
m.data<- na.omit(m.data)
w.mu <- mean(w.data$seals)
m.mu <- mean(m.data$seals)
# Waterfront
set.seed(5432)
w.sample <- length(w.data$seals) # Sample size in one run of the experiment (i.e. number of observations we have)
w.data$seals <- round(80 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
# Marina
m.sample <- length(m.data$seals) # Sample size in one run of the experiment (i.e. number of observations we have)
m.data$seals <- round(100 - 0.8*m.data$noise - 2*m.data$tide - 5*m.data$month + abs(round(rnorm(m.sample, mean=m.mu,sd=10))))
# Merge data
seal.data<-merge(w.data,m.data,all = T)
seal.data$site<- as.numeric(seal.data$site=="waterfront")
# Hypotheses 2 & 3
full.mod <- lm(seals ~ noise*site + tide + month, data = seal.data)
summary(full.mod)
# Check RMSE
pred.full <- predict(full.mod, newdata=seal.data)
rmse.full <- sqrt(mean(truth-pred.full)^2)
pred.full
# Check RMSE
truth <- seal.data$seals
pred.full <- predict(full.mod, newdata=seal.data)
rmse.full <- sqrt(mean(truth-pred.full)^2)
rmse.full
