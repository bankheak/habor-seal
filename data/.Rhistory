spwn=0.8 # Spawning success
p=0.3 # Reproduction frequency
if(stochastic==0) a.surv=Adults * s else a.surv=rbinom(1,Adults,s)
# eggs produced by A_t+1
if(stochastic==0) a.eggs=(a.surv + Adults_t1) * (egga*s0*spwn*p) else a.eggs=rbinom(1,(a.surv + Adults_t1),(egga*s0*spwn*p))
return(list(Adult=a.surv, Eggs=a.eggs))
}
# Create final function with above info
Sturgen.Pop<- function(mtx, yrs, stochastic=0){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd[i], stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult[i], stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
pop.matrix<- cbind(Eggs.t = 11383+73465,
Juv.t = Total*0.123,
Marine.t = Total*0.359,
SubA.t=Total*0.191,
YoungA.t=Total*0.173,
Adult.t=Total*0.154)
# Create final function with above info
Sturgen.Pop<- function(mtx, yrs){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd[i], stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult[i], stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years)
# Make sure the stochastic functions work outside of the final function
mtx2=array(NA,dim=c(length(sim.years)+1,6))
mtx2[1,] = pop.matrix
for (i in 1:length(sim.years)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd[i], stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult[i], stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")}
warnings()
mtx2
Juveniles<- num.juv(Juveniles=mtx2[1,2], Eggs=mtx2[1,1], stochastic=1)
Juveniles
pop.matrix
# Create final function with above info
Sturgen.Pop<- function(mtx, yrs){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd[i], stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult[i], stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years)
sturg.mtx
profvis::profvis({Sturgen.Pop(mtx = pop.matrix, yrs = sim.years)})
## test to see how fast the functions are
profvis::profvis({Sturgen.Pop<- function(mtx, yrs){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd[i], stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult[i], stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}})
# Create final function with above info
## WOULD HAVE MADE IT EASIER IF YOU ALLOWED stochastic
## TO BE INPUT TO THE Sturgen.Pop FUNCTION
Sturgen.Pop<- function(mtx, yrs){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd, stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult, stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years)
sturg.mtx
# Create final function with above info
## WOULD HAVE MADE IT EASIER IF YOU ALLOWED stochastic
## TO BE INPUT TO THE Sturgen.Pop FUNCTION
Sturgen.Pop<- function(mtx, yrs, stochastic=0){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1])
Marine<-num.mar(Marine=mtx2[i,3])
SubA<-num.sub(SubA=mtx2[i,4])
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years, stochastic=1)
sturg.mtx
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years, stochastic=1)
sturg.mtx
beta.mom<- function(mn, s){
v=s**2
x=mn
a<-x*(x*(1-x)/v-1)
b<- (1-x)*(x*(1-x)/v-1)
c(a,b)
}
o<- function(mn, s){
beta.parm<- beta.mom(mn, s)
mn.occ<- rbeta(10, beta.parm[1], beta.parm[2])
i.occ<- rbinom(10, 1, mn.occ)
i.occ
}
initial.occupancy<- o(mn = 0.7, s = 0.2)
#' 2) persistence
# Back transform to get probabilities associated with precipitation
## Distribution of summer.ppt
gamma.mom<- function(mn, s){
v= s**2
x= mn
a<- (mn/s)^2
b<- (s^2)/mn
c(a, b)
}
p<- function(mn, s, ic){
gamma.parm<- gamma.mom(mn, s)
summer.ppt<-rgamma(1,gamma.parm[1],gamma.parm[2])
logit.persistence = - 4.7514 + 0.030577*summer.ppt
persis<- 1/(1+exp(-logit.persistence))
persist<- rbinom(10, ic, persis)
return(persist)
}
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
coln<- 1/(1+exp(-logit.colonization))
distan
#' 3) colonization
#' Back transform to get probabilities associated with colonization
colonize<- function(persistance){
# this creates a pairwise distances between wetlands
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
coln<- 1/(1+exp(-logit.colonization))
# Now ask if vector is occupied or not
for (col in 1:coln(distan)) {
if (persistance[col]==0)
persistance[col]<-min(sum(rbinom(length(persistance[-col]),
persistance[col],coln[col,-col])), 1)
}
return(persistance)
}
colonization<- colonize(persistance = persistance)
?ncol
#' 3) colonization
#' Back transform to get probabilities associated with colonization
colonize<- function(persistance){
# this creates a pairwise distances between wetlands
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
p<- 1/(1+exp(-logit.colonization))
# Now ask if vector is occupied or not
for (col in 1:ncol(distan)) {
if (persistance[col]==0)
persistance[col]<-min(sum(rbinom(length(persistance[-col]),
persistance[col],p[col,-col])), 1)
}
return(persistance)
}
colonization<- colonize(persistance = persistance)
colonization
final.occ<- function(yrs)
final.occ<- function(yrs){
initial.occupancy<- o(mn = 0.7, s = 0.2)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
vect<- NULL
for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(p.mean, p.sd, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
final.occ<- function(yrs){
initial.occupancy<- o(mn = 0.7, s = 0.2)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
vect<- NULL
for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(180, 70, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
newt.occ
# Check difference with site
pred_interval <- predict(full.mod, newdata=data.frame(X1=seq(0, 25, by=0.05)), interval="prediction",
level = 0.95)
# Organize Data -----------------------------------------------------------
# Set working directory here
setwd("C:/Users/bankh/My_Repos/habor-seal/data")
# Require packages
require(ggplot2)
# Retrieve data
m.data<-read.csv("m.data.csv")
w.data<-read.csv("new.w.data.csv")
# Create organized dataset
w.data$seals<- ifelse(w.data$seals>0,w.data$seals,NA)
m.data$seals<- ifelse(m.data$seals>0,m.data$seals,NA)
w.data<- na.omit(w.data)
m.data<- na.omit(m.data)
w.mu <- mean(w.data$seals)
m.mu <- mean(m.data$seals)
# Waterfront
set.seed(5432)
w.sample <- length(w.data$seals) # Sample size in one run of the experiment (i.e. number of observations we have)
w.data$seals <- round(60 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
# Marina
m.sample <- length(m.data$seals) # Sample size in one run of the experiment (i.e. number of observations we have)
m.data$seals <- round(100 - 0.8*m.data$noise - 2*m.data$tide - 5*m.data$month + abs(round(rnorm(m.sample, mean=m.mu,sd=10))))
# Merge data
seal.data<-merge(w.data,m.data,all = T)
seal.data$site<- as.numeric(seal.data$site=="waterfront")
# Check distribution
hist(seal.data$seals)
# Run pairwise cor between all independent variables
## Cut-off is +/- 0.7
cor.matrix<-cor(seal.data[,c(2:4,6)])
# Keep only large correlations in the same model
cor.matrix[abs(cor.matrix)< 0.7]<-NA
cor.matrix
# Check out plot of seals vs noise
plot(seal.data$seals~ seal.data$noise)
# Check out Residuals
fit1<- lm(seals ~ noise*site + tide + month, data = seal.data)
summary(fit1)
plot(fit1$fitted, fit1$resid, xlab="Fitted Values", ylab="Residuals", pch=16)
abline(h=0)
# Fit Models --------------------------------------------------------------
# Hypothesis 1
t.test(seal.data$noise[seal.data$site == 1], seal.data$noise[seal.data$site == 0])
## Graph differences
x.order <- c('Waterfront', 'Marina')
ggplot(seal.data, aes(x = site, y = noise)) +
geom_violin(fill = "grey")+ geom_boxplot(width = .2)+xlab("Site")+
ylab("Average Noise Level (dB)")+scale_x_discrete(limit = c("waterfront", "marina"),
labels = c("Waterfront","Marina"))+theme(panel.background = element_blank())
# Hypotheses 2 & 3
full.mod <- lm(seals ~ noise*site + tide + month, data = seal.data)
# Check difference with site
pred_interval <- predict(full.mod, newdata=data.frame(X1=seq(0, 25, by=0.05)), interval="prediction",
level = 0.95)
View(seal.data)
round(100 - 0.8*m.data$noise - 2*m.data$tide - 5*m.data$month + abs(round(rnorm(m.sample, mean=m.mu,sd=10))))
round(60 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
round(100 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
round(70 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
round(75 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
round(80 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
w.data$seals <- round(80 - 0.4*w.data$noise - 2*w.data$tide - 5*w.data$month + abs(round(rnorm(w.sample, mean=w.mu,sd=10))))
m.data$seals <- round(100 - 0.8*m.data$noise - 2*m.data$tide - 5*m.data$month + abs(round(rnorm(m.sample, mean=m.mu,sd=10))))
# Merge data
seal.data<-merge(w.data,m.data,all = T)
seal.data$site<- as.numeric(seal.data$site=="waterfront")
# Check out plot of seals vs noise
plot(seal.data$seals~ seal.data$noise)
plot(fit1$fitted, fit1$resid, xlab="Fitted Values", ylab="Residuals", pch=16)
abline(h=0)
# Fit Models --------------------------------------------------------------
# Hypothesis 1
t.test(seal.data$noise[seal.data$site == 1], seal.data$noise[seal.data$site == 0])
# Hypotheses 2 & 3
full.mod <- lm(seals ~ noise*site + tide + month, data = seal.data)
# Check difference with site
pred_interval <- predict(full.mod, newdata=data.frame(X1=seq(0, 25, by=0.05)), interval="prediction",
level = 0.95)
summary(full.mod)
predict(full.mod, newdata=data.frame(X1=seq(0, 25, by=0.05)), interval="prediction",
level = 0.95)
full.mod
# Check difference with site
x<- seq(0, 25, by=0.05))
# Check difference with site
x<- seq(0, 25, by=0.05)
pred_interval <- predict(full.mod, newdata=data.frame(X1=x), interval="prediction",
level = 0.95)
# Check difference with site
newdata2 <- data.frame(
noise = rep(seq(from = min(seal.data$noise), to = max(seal.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(seal.data$site)))
pred_interval <- predict(full.mod, newdata=newdata2, interval="prediction",
level = 0.95)
# Check difference with site
new.mod <- lm(seals ~ noise*site, data = seal.data)
newdata2 <- data.frame(
noise = rep(seq(from = min(seal.data$noise), to = max(seal.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(seal.data$site)))
pred_interval <- predict(new.mod, newdata=newdata2, interval="prediction",
level = 0.95)
pred_interval
class(seal.data$site)
seal.data$site<- as.factor(seal.data$site)
class(seal.data$site)
# Check difference with site
new.mod <- lm(seals ~ noise*site, data = seal.data)
newdata2 <- data.frame(
noise = rep(seq(from = min(seal.data$noise), to = max(seal.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(seal.data$site)))
pred_interval <- predict(new.mod, newdata=newdata2, interval="prediction",
level = 0.95)
plot(seal.data$noise[seal.data$site==1],seal.data$seals[seal.data$site==1],
type="p",pch=19, col="blue", xlab="Noise Level (dB)",ylab="Number of Seals Hauled-out",
xlim = c(min(seal.data$noise),max(seal.data$noise)), ylim=c(min(seal.data$seals), max(seal.data$seals)))
abline(lm(seal.data$seals[seal.data$site==1]~seal.data$noise[seal.data$site==1]),col="blue")
points(seal.data$noise[seal.data$site==0],seal.data$seals[seal.data$site==0],type="p",pch=19, col="red") # add points corresponding to polymer 2
abline(lm(seal.data$seals[seal.data$site==0]~seal.data$noise[seal.data$site==0]),col="red") # add regression line for polymer 2
lines(new.mod, pred_interval[,2], col="darkgreen", lty=2)
lines(newdata2, pred_interval[,2], col="darkgreen", lty=2)
newdata2
pred_interval
lines(pred_interval[,1], pred_interval[,2], col="darkgreen", lty=2)
newdata2
newdata2 <- data.frame(
noise = rep(seq(from = min(seal.data$noise), to = max(seal.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(seal.data$site)))
pred_interval1 <- predict(new.mod, newdata=newdata2[newdata2$site==1], interval="prediction",
level = 0.95)
pred_interval1 <- predict(new.mod, newdata=newdata2[c(1:100),], interval="prediction",
level = 0.95)
pred_interval2 <- predict(new.mod, newdata=newdata2[c(101:200),], interval="prediction",
level = 0.95)
plot(seal.data$noise[seal.data$site==1],seal.data$seals[seal.data$site==1],
type="p",pch=19, col="blue", xlab="Noise Level (dB)",ylab="Number of Seals Hauled-out",
xlim = c(min(seal.data$noise),max(seal.data$noise)), ylim=c(min(seal.data$seals), max(seal.data$seals)))
abline(lm(seal.data$seals[seal.data$site==1]~seal.data$noise[seal.data$site==1]),col="blue")
points(seal.data$noise[seal.data$site==0],seal.data$seals[seal.data$site==0],type="p",pch=19, col="red")
abline(lm(seal.data$seals[seal.data$site==0]~seal.data$noise[seal.data$site==0]),col="red")
lines(pred_interval[,1], pred_interval[,2], col="darkgreen", lty=2)
lines(newdata2, pred_interval[,2], col="darkgreen", lty=2)
newdata2
lines(newdata2[c(1:100),1], pred_interval[,2], col="darkgreen", lty=2)
newdata2[c(1:100),1]
pred_interval[,2]
lines(newdata2[c(1:100),1], pred_interval[c(1:100),2], col="darkgreen", lty=2)
lines(newdata2[c(1:100),1], pred_interval[c(1:100),3], col="darkgreen", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),2], col="darkgreen", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),3], col="darkgreen", lty=2)
plot(seal.data$noise[seal.data$site==1],seal.data$seals[seal.data$site==1],
type="p",pch=19, col="blue", xlab="Noise Level (dB)",ylab="Number of Seals Hauled-out",
xlim = c(min(seal.data$noise),max(seal.data$noise)), ylim=c(min(seal.data$seals), max(seal.data$seals)))
abline(lm(seal.data$seals[seal.data$site==1]~seal.data$noise[seal.data$site==1]),col="blue")
points(seal.data$noise[seal.data$site==0],seal.data$seals[seal.data$site==0],type="p",pch=19, col="red")
abline(lm(seal.data$seals[seal.data$site==0]~seal.data$noise[seal.data$site==0]),col="red")
lines(newdata2[c(1:100),1], pred_interval[c(1:100),2], col="blue", lty=2)
lines(newdata2[c(1:100),1], pred_interval[c(1:100),3], col="blue", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),2], col="red", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),3], col="red", lty=2)
legend(62, 80, legend=c("Waterfront", "Marina"),
col=c("blue", "red"), lty=1, cex=0.8)
plot(seal.data$noise[seal.data$site==1],seal.data$seals[seal.data$site==1],
type="p",pch=19, col="blue", xlab="Noise Level (dB)",ylab="Number of Seals Hauled-out",
xlim = c(min(seal.data$noise),max(seal.data$noise)), ylim=c(min(seal.data$seals), max(seal.data$seals)))
abline(lm(seal.data$seals[seal.data$site==1]~seal.data$noise[seal.data$site==1]),col="blue")
points(seal.data$noise[seal.data$site==0],seal.data$seals[seal.data$site==0],type="p",pch=19, col="red")
abline(lm(seal.data$seals[seal.data$site==0]~seal.data$noise[seal.data$site==0]),col="red")
lines(newdata2[c(1:100),1], pred_interval[c(1:100),2], col="blue", lty=2)
lines(newdata2[c(1:100),1], pred_interval[c(1:100),3], col="blue", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),2], col="red", lty=2)
lines(newdata2[c(101:200),1], pred_interval[c(101:200),3], col="red", lty=2)
legend(62, 85, legend=c("Waterfront", "Marina"),
col=c("blue", "red"), lty=1, cex=0.8)
