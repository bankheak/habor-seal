## WOULD HAVE MADE IT EASIER IF YOU ALLOWED stochastic
## TO BE INPUT TO THE Sturgen.Pop FUNCTION
Sturgen.Pop<- function(mtx, yrs){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1], stochastic=1)
Marine<-num.mar(Marine=mtx2[i,3], stochastic=1)
SubA<-num.sub(SubA=mtx2[i,4], stochastic=1)
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd, stochastic=1)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult, stochastic=1)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years)
sturg.mtx
# Create final function with above info
## WOULD HAVE MADE IT EASIER IF YOU ALLOWED stochastic
## TO BE INPUT TO THE Sturgen.Pop FUNCTION
Sturgen.Pop<- function(mtx, yrs, stochastic=0){
# Make array to contain progression in years
mtx2=array(NA,dim=c(length(yrs)+1,6))
mtx2[1,] = mtx
for (i in 1:length(yrs)) {
# Create animals at t+1 i=2
Juveniles<- num.juv(Juveniles=mtx2[i,2], Eggs=mtx2[i,1])
Marine<-num.mar(Marine=mtx2[i,3])
SubA<-num.sub(SubA=mtx2[i,4])
YoungA<- num.y(YoungAd = mtx2[i,5], YoungAd_t1 = SubA$YoungAd)
Adult<- num.a(Adults = mtx2[i,6], Adults_t1 = YoungA$Adult)
if(is.na(Adult$Eggs)) Adult$Eggs=0
if(is.na(YoungA$Eggs)) YoungA$Eggs=0
## Assign animals at t+1 to animals at t
mtx2[i+1,]<- cbind(Juv.t= round(Juveniles$Juveniles),
Marine.t = round(Juveniles$Marine.juves + Marine$Marine.juves),
SubA.t=round(SubA$SubA + Marine$Subsdults),
YoungA.t=round(YoungA$YoungAd + SubA$YoungAd),
Adult.t=round(Adult$Adult + YoungA$Adult),
Eggs.t=round(YoungA$Eggs + Adult$Eggs))
colnames(mtx2)<- c("Eggs", "Juveniles", "Marine Juveniles", "SubAdults",
"Young Adults", "Adults")
}
return(mtx2)
}
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years, stochastic=1)
sturg.mtx
sturg.mtx<-Sturgen.Pop(mtx = pop.matrix, yrs = sim.years, stochastic=1)
sturg.mtx
beta.mom<- function(mn, s){
v=s**2
x=mn
a<-x*(x*(1-x)/v-1)
b<- (1-x)*(x*(1-x)/v-1)
c(a,b)
}
o<- function(mn, s){
beta.parm<- beta.mom(mn, s)
mn.occ<- rbeta(10, beta.parm[1], beta.parm[2])
i.occ<- rbinom(10, 1, mn.occ)
i.occ
}
initial.occupancy<- o(mn = 0.7, s = 0.2)
#' 2) persistence
# Back transform to get probabilities associated with precipitation
## Distribution of summer.ppt
gamma.mom<- function(mn, s){
v= s**2
x= mn
a<- (mn/s)^2
b<- (s^2)/mn
c(a, b)
}
p<- function(mn, s, ic){
gamma.parm<- gamma.mom(mn, s)
summer.ppt<-rgamma(1,gamma.parm[1],gamma.parm[2])
logit.persistence = - 4.7514 + 0.030577*summer.ppt
persis<- 1/(1+exp(-logit.persistence))
persist<- rbinom(10, ic, persis)
return(persist)
}
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
coln<- 1/(1+exp(-logit.colonization))
distan
#' 3) colonization
#' Back transform to get probabilities associated with colonization
colonize<- function(persistance){
# this creates a pairwise distances between wetlands
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
coln<- 1/(1+exp(-logit.colonization))
# Now ask if vector is occupied or not
for (col in 1:coln(distan)) {
if (persistance[col]==0)
persistance[col]<-min(sum(rbinom(length(persistance[-col]),
persistance[col],coln[col,-col])), 1)
}
return(persistance)
}
colonization<- colonize(persistance = persistance)
?ncol
#' 3) colonization
#' Back transform to get probabilities associated with colonization
colonize<- function(persistance){
# this creates a pairwise distances between wetlands
set.seed(54321)
distan<-matrix(round(runif(100,0.2,1)*10,2),ncol=10,nrow=10)
diag(distan)=0      # makes the diagonal zero
for(col in 1:10){   # nested loop makes the matrix symmetrical
for(row in 1:10){
distan[col,row] = distan[row,col]
}
}
logit.colonization<- 4.8 - 1.48*distan
p<- 1/(1+exp(-logit.colonization))
# Now ask if vector is occupied or not
for (col in 1:ncol(distan)) {
if (persistance[col]==0)
persistance[col]<-min(sum(rbinom(length(persistance[-col]),
persistance[col],p[col,-col])), 1)
}
return(persistance)
}
colonization<- colonize(persistance = persistance)
colonization
final.occ<- function(yrs)
final.occ<- function(yrs){
initial.occupancy<- o(mn = 0.7, s = 0.2)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
vect<- NULL
for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(p.mean, p.sd, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
final.occ<- function(yrs){
initial.occupancy<- o(mn = 0.7, s = 0.2)
persistance<- p(mn = 180, s = 70, ic = initial.occupancy)
vect<- NULL
for (i in 1:yrs) {
colonization<- colonize(persistance = persistance)
persistance<- p(180, 70, ic = colonization[i])
vect<-c(vect,mean(persistance))
}
return(vect)
}
newt.occ<- final.occ(yrs = 10)
newt.occ
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years, decision){
#   N.suitable=50
#   N.unsuit=50
#   years=50
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4)
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
# Beta Function
beta.mom<-function(mean,v){
x<-mean
a<-x*(x*(1-x)/v-1)
b<-(1-x)*(x*(1-x)/v-1)
c(a,b)}
# Extinction
colon_extinct_vect<-function(p.persist,N.occupied.t,p.colon, N.empty.t){
N.occupied.t.plus<-rbinom(length(N.occupied.t),N.occupied.t,p.persist)+
rbinom(length(N.empty.t),N.empty.t,p.colon)
return(c(N.occupied.t.plus))}
# Initial Occupancy
initial_occup_vect<-function(p.persist,p.colon, N.suitable){
p.initial<- p.colon/(p.colon + (1-p.persist))
N.occupied.t<-rbinom(length(N.suitable),N.suitable,p.initial)
return(c(N.occupied.t))}
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(1,1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Veg dynamics
veg.dynamics_vect<-function(N.suitable,N.unsuit,time,hurricane){
Total.patch= N.suitable + N.unsuit
N.unsuit <- N.unsuit + ifelse(hurricane==1,rbinom(length(N.suitable),N.suitable,0.5),0)
N.suitable <- Total.patch - N.unsuit
time <- ifelse(hurricane==1, 0, time + 1)
wt.slow<-0.5
wt.fast<- 1- wt.slow
p.suitable<- 1/(1+exp(-(-5 + 0.05*time + 0.05*time^2)))*wt.slow +
1/(1+exp(-(-5 + 0.75*time)))*wt.fast
N.suitable <- N.suitable + rbinom(length(N.suitable),N.unsuit,p.suitable)
N.unsuit<- Total.patch - N.suitable
veg.data<- cbind(N.suitable,N.unsuit,time)
return(veg.data)}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years, decision){
#   N.suitable=50
#   N.unsuit=50
#   years=50
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
# Change Persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(length(hurricane),cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
# Change persistence
change.persistence_vect<-function(decision, hurricane){
p.persist.hat<- 0.75
p.persist.var<- 0.05
cur.per.beta<-beta.mom(p.persist.hat,p.persist.var)
p.persist.curr<-rbeta(1,cur.per.beta[1],cur.per.beta[2])
if (decision==2){
ln.odds<- log(p.persist.curr/(1-p.persist.curr))
change<- rnorm(length(hurricane),1.3,0.17)
p.persist<- 1/(1+exp(-(ln.odds*change)))
} else p.persist <- p.persist.curr
p.persist<-ifelse(hurricane==1, 0.3,p.persist)
return(p.persist)
}
#' Mouse dynamics function
mouse.patch.dyn_vect<-function(N.suitable,N.unsuit,years,decision){
# set initial values
p.colon.hat<- 0.5
p.colon.var<- 0.1
beta.colon<-beta.mom(p.colon.hat,p.colon.var)
p.persist.hat=0.75
time=0
# initial occupancy
occ.states<-initial_occup_vect(p.persist=p.persist.hat,p.colon=p.colon.hat, N.suitable=N.suitable)
# place to hold proportion occupied
for(yr in 1:years){
# implement decision in year 5
decis<- ifelse(yr==5,decision,1)
hurricane<-rbinom(length(N.suitable),1,0.02)
p.persist=change.persistence_vect(decision=decis,hurricane=hurricane)
p.colon<-rbeta(length(N.suitable),beta.colon[1],beta.colon[2])
# if nothing is occupied colonization is zero
p.colon<-ifelse(occ.states > 0,p.colon,0)
occ.states<- colon_extinct_vect(p.persist=p.persist,N.occupied.t=occ.states,
p.colon=p.colon, N.empty.t=(N.suitable-occ.states))
tmp<-veg.dynamics_vect(N.suitable=N.suitable,N.unsuit=N.unsuit,time=time,
hurricane=hurricane)
N.suitable=tmp[,1]
N.unsuit=tmp[,2]
time=tmp[,3]
# restore 5 patches decision
N.suitable=ifelse(decis==3, N.suitable+5, N.suitable)
Total.ptch = N.suitable+N.unsuit
}
occ.states<-ifelse(is.na(occ.states),0,occ.states)
return(occ.states)
}
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
dec.1<-mouse.patch.dyn_vect(N.suitable=rep(50, 1e4),N.unsuit=rep(50,1e4),
years= 50, decision=rep(1, 1e4))
dec.1
# Set working directory here
setwd("C:/Users/bankh/My_Repos/habor-seal/data")
# Retrieve data
m.data<-read.csv("m.data.csv")
new.w.data<-read.csv("new.w.data.csv")
# Load packages
require(ggplot2)
library(ggpubr)
# Load packages
require(ggplot2)
install.packages("ggplot2")
# Load packages
require(ggplot2)
library(ggpubr)
install.packages("ggpubr")
library(ggpubr)
## Waterfront
p<-ggplot(new.w.data, aes(x=month,y =seals,group=month))
a<- p+geom_boxplot(fill="blue", alpha=0.2) +
xlab("Month")+ylab("Number of Seals Hauled-out")+
theme(panel.background = element_blank())
a + scale_x_discrete(limits = c(6,7,8,9,10,11),
labels=c("Jun", "Jul", "Aug", "Sept", "Oct", "Nov"))
## Marina
j<-ggplot(m.data, aes(x=month,y =seals,group=month))
k<- j+geom_boxplot(fill="#F8766D", alpha=0.2)+
xlab("Month")+ylab("Number of Seals Hauled-out")+
theme(panel.background = element_blank())
k + scale_x_discrete(limits = c(6,7,8,9,10,11),
labels=c("Jun", "Jul", "Aug", "Sept", "Oct", "Nov"))
ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
library(ggpubr)
if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/ggpubr")
ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
ggpubr::ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
install.packages("vctrs")
install.packages("vctrs")
install.packages("vctrs")
require(vctrs)
library(ggpubr)
install.packages("ggpubr")
library(ggpubr)
install.packages(c("AICcmodavg", "ape", "bayestestR", "cachem", "cli", "colorspace", "commonmark", "data.table", "datawizard", "DEoptimR", "dplyr", "effectsize", "emmeans", "fansi", "fastmap", "fontawesome", "fs", "gdtools", "ggeffects", "gh", "glmmTMB", "HelpersMG", "Hmisc", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "insight", "interp", "knitr", "markdown", "MASS", "Matrix", "mgcv", "modelr", "multcomp", "MuMIn", "networkLite", "nlme", "openssl", "parameters", "performance", "ps", "Rcpp", "RcppArmadillo", "rmarkdown", "robustbase", "Rttf2pt1", "sass", "sjPlot", "sourcetools", "styler", "survival", "tibble", "tinytex", "TMB", "triebeard", "utf8", "vctrs", "VGAM", "xfun", "yaml"))
install.packages(c("AICcmodavg", "ape", "bayestestR", "cachem", "cli", "colorspace", "commonmark", "data.table", "datawizard", "DEoptimR", "dplyr", "effectsize", "emmeans", "fansi", "fastmap", "fontawesome", "fs", "gdtools", "ggeffects", "gh", "glmmTMB", "HelpersMG", "Hmisc", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "insight", "interp", "knitr", "markdown", "MASS", "Matrix", "mgcv", "modelr", "multcomp", "MuMIn", "networkLite", "nlme", "openssl", "parameters", "performance", "ps", "Rcpp", "RcppArmadillo", "rmarkdown", "robustbase", "Rttf2pt1", "sass", "sjPlot", "sourcetools", "styler", "survival", "tibble", "tinytex", "TMB", "triebeard", "utf8", "vctrs", "VGAM", "xfun", "yaml"))
# Load packages
require(ggplot2)
library(ggpubr)
install.packages("vctrs")
install.packages("vctrs")
install.packages("vctrs")
library(ggpubr)
require(vctrs)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggpubr")
# Load packages
require(ggplot2)
install.packages("ggpubr")
library(ggpubr)
remove.packages(vctrs)
remove.packages("vctrs)
remove.packages("vctrs")
install.packages("vctrs")
remove.packages("vctrs")
install.packages("vctrs")
install.packages("vctrs")
install.packages("ggplot2")
install.packages("ggplot2")
remove.packages("ggplot2")
remove.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggplot2")
install.packages("ggpubr")
library(ggpubr)
theme_set(theme_pubr())
figure<- ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
rlang::last_trace()
ggarrange(a, k,
labels = c("A", "B"))
figure<- ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
rlang::last_trace()
figure<- ggarrange(a, k)
remove.packages("ggpubr")
install.packages("ggpubr")
install.packages("ggpubr")
library(ggpubr)
figure<- ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
library(ggpubr)
figure<- ggarrange(a, k,
labels = c("A", "B"),
ncol = 1, nrow = 2)
