summary(fit1)
summary(fit1)$coef
# Quadratic
fit2 <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
summary(fit2)["r.squared"]
summary(fit2)$coef
# Cubic
fit3 <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
summary(fit3)
summary(fit3)$coef
data <- read.csv("ex0915.csv")
attach(data)
# Linear
fit1 <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
summary(fit1)["r.squared"]
summary(fit1)$coef
# Quadratic
fit2 <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
summary(fit2)["r.squared"]
summary(fit2)$coef
# Cubic
fit3 <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
summary(fit3)
summary(fit3)$coef
data <- read.csv("ex0915.csv")
attach(data)
# Linear
fit1 <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
summary(fit1)["r.squared","adj.r.squared"]
data <- read.csv("ex0915.csv")
attach(data)
# Linear
fit1 <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
summary(fit1)["r.squared"]["adj.r.squared"]
summary(fit1)$coef
# Quadratic
fit2 <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
summary(fit2)["r.squared"]
summary(fit2)$coef
# Cubic
fit3 <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
summary(fit3)
summary(fit3)$coef
data <- read.csv("ex0915.csv")
attach(data)
# Linear
fit1 <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
summary(fit1)["r.squared"]
summary(fit1)["adj.r.squared"]
summary(fit1)$coef
# Quadratic
fit2 <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
summary(fit2)["r.squared"]
summary(fit2)["adj.r.squared"]
summary(fit2)$coef
# Cubic
fit3 <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
summary(fit3)["r.squared"]
summary(fit3)["adj.r.squared"]
summary(fit3)$coef
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anova(red.mod, full.mod)
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov2<-anova(full.mod)
# F-Stat
sst<- sum(anov2["Sum Sq"])
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov2<-anova(full.mod)
anov2
# F-Stat
sst<- sum(anov2["Sum Sq"])
full.mod <- lm(Yield ~ Rainfall+ I(Rainfall^2)+I(Rainfall^3))
anov2<-anova(full.mod)
anov2
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov2<-anova(full.mod)
anov2
# F-Stat
sst<- anov2$"Sum Sq"[1]
sst
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov1<-anova(red.mod)
anov2<-anova(full.mod)
## Full
ssres.f<- anov2$"Sum Sq"[2]
ssreg.f<- anov2$"Sum Sq"[1]
sst.f<- sum(anov2$"Sum Sq"[1:2])
dfres.f<- anov2$"Df"[2]
dfreg.f<- anov2$"Df"[1]
dft.f<- sum(anov2$"Df"[1:2])
## Reduced
ssres.r<- anov1$"Sum Sq"[2]
ssreg.r<- anov1$"Sum Sq"[1]
sst.r<- sum(anov1$"Sum Sq"[1:2])
dfres.r<- anov1$"Df"[2]
dfreg.r<- anov1$"Df"[1]
dft.r<- sum(anov1$"Df"[1:2])
# ESS F-stat
((ssres.r-ssres.f)/(dfres.r-dfres.f))/(ssres.f/dfres.f)
dft.f
dft.r
dfres.r
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov1<-anova(red.mod)
anov2<-anova(full.mod)
## Full
ssres.f<- anov2$"Sum Sq"[2]
ssreg.f<- anov2$"Sum Sq"[1]
sst.f<- sum(anov2$"Sum Sq"[1:2])
dfres.f<- anov2$"Df"[2]
dfreg.f<- anov2$"Df"[1]
dft.f<- sum(anov2$"Df"[1:2])
## Reduced
ssres.r<- anov1$"Sum Sq"[2]
ssreg.r<- anov1$"Sum Sq"[1]
sst.r<- sum(anov1$"Sum Sq"[1:2])
dfres.r<- anov1$"Df"[2]
dfreg.r<- anov1$"Df"[1]
dft.r<- sum(anov1$"Df"[1:2])
# ESS F-stat
f<-((ssres.r-ssres.f)/(dfres.r-dfres.f))/(ssres.f/dfres.f)
f
# p-value
pf(f, 1, 35, lower.tail = FALSE)
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov1<-anova(red.mod)
anov2<-anova(full.mod)
## Full
ssres.f<- anov2$"Sum Sq"[2]
ssreg.f<- anov2$"Sum Sq"[1]
sst.f<- sum(anov2$"Sum Sq"[1:2])
dfres.f<- anov2$"Df"[2]
dfreg.f<- anov2$"Df"[1]
dft.f<- sum(anov2$"Df"[1:2])
## Reduced
ssres.r<- anov1$"Sum Sq"[2]
ssreg.r<- anov1$"Sum Sq"[1]
sst.r<- sum(anov1$"Sum Sq"[1:2])
dfres.r<- anov1$"Df"[2]
dfreg.r<- anov1$"Df"[1]
dft.r<- sum(anov1$"Df"[1:2])
# ESS F-stat
f<-((ssres.r-ssres.f)/(dfres.r-dfres.f))/(ssres.f/dfres.f)
f
# p-value
pf(f, 1, 37, lower.tail = FALSE)
data <- read.csv("ex0915.csv")
attach(data)
# Linear
red.mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
# Quadratic
full.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
anova(red.mod, full.mod)
# Quadratic
red.mod <- lm(Yield ~ poly(Rainfall,2,raw=TRUE))
# Cubic
full.mod <- lm(Yield ~ poly(Rainfall,3,raw=TRUE))
anov1<-anova(red.mod)
anov2<-anova(full.mod)
## Full
ssres.f<- anov2$"Sum Sq"[2]
ssreg.f<- anov2$"Sum Sq"[1]
sst.f<- sum(anov2$"Sum Sq"[1:2])
dfres.f<- anov2$"Df"[2]
dfreg.f<- anov2$"Df"[1]
dft.f<- sum(anov2$"Df"[1:2])
## Reduced
ssres.r<- anov1$"Sum Sq"[2]
ssreg.r<- anov1$"Sum Sq"[1]
sst.r<- sum(anov1$"Sum Sq"[1:2])
dfres.r<- anov1$"Df"[2]
dfreg.r<- anov1$"Df"[1]
dft.r<- sum(anov1$"Df"[1:2])
# ESS F-stat
f<-((ssres.r-ssres.f)/(dfres.r-dfres.f))/(ssres.f/dfres.f)
f
# p-value
pf(f, 1, 34, lower.tail = FALSE)
data <- read.csv("ex0915.csv")
attach(data)
mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
plot(Year,mod$res, pch=20, col="blue")
data <- read.csv("ex0915.csv")
attach(data)
mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
plot(Year,mod$res, pch=20, col="blue")
abline(h=0)
data <- read.csv("ex0915.csv")
attach(data)
mod <- lm(Yield ~ poly(Rainfall,1,raw=TRUE))
plot(Year,mod$res, pch=20, col="blue")
abline(h=0)
# Parameters
s=0.93 # Survival
Mm=0.54 # Transition to marine juvenile
Ms=0.11 # Transition to subadult
My=0.13 # Transition to young adult
Ma=0.07 # Transition to adult
eggy=11383 # Eggs young adult
egga=73465 # Eggs adult
s0=0.00002 # Egg to age-1 survival
spwn=0.8 # Spawning success
p=0.3 # Reproduction frequency
#Consider a simple population with age/ stage classes:
# per capita fecundity juvenile
Fj = 1.1
# per capita fecundity adult
Fa = 2.1
#survival age 0
S0 = 0.25
Sj = 0.35
#survival adult
Sa = 0.75
#We create the population transition matrix
trans.mtrx = matrix(c(0,Fj,Fa,S0,0,0,0,Sj,Sa), ncol = 3, byrow = T)
trans.mtrx
# Population transition matrix --------------------------------------------
trans.mtrx = matrix(c(0,0,0,0,Fy,Fa,
s0,Sj,0,0,0,0,
0,Tm,Sm,0,0,0,
0,0,Ts,Ss,0,0,
0,0,0,Ty,Sy,0,
0,0,0,0,Ta,Sa), ncol = 6, byrow = T)
# Parameters
s=0.93 # Survival
Mm=0.54 # Transition to marine juvenile
Ms=0.11 # Transition to subadult
My=0.13 # Transition to young adult
Ma=0.07 # Transition to adult
eggy=11383 # Eggs young adult
egga=73465 # Eggs adult
spwn=0.8 # Spawning success
p=0.3 # Reproduction frequency
# Survival
s0=0.00002 # Egg to age-1 survival
Sj = s*(1-Mm) # Juvenile survival
Sm = s*(1-Ms) # Marine survival
Ss = s*(1-My) # Subadult survival
Sy = s*(1-Ma) # Young adult survival
Sa = s # Adult survival
# Transitions
Tm = s*Mm # Juvenile to marine
Ts = s*Ms # Marine to subadult
Ty = s*My # Sub to young adult
Ta = s*Ma # Young adult to adult
# Fecundity
Fy = eggy*s0*spwn*p # annual fecundity young adult
Fa = egga*s0*spwn*p # annual fecundity adult
# Population transition matrix --------------------------------------------
trans.mtrx = matrix(c(0,0,0,0,Fy,Fa,
s0,Sj,0,0,0,0,
0,Tm,Sm,0,0,0,
0,0,Ts,Ss,0,0,
0,0,0,Ty,Sy,0,
0,0,0,0,Ta,Sa), ncol = 6, byrow = T)
trans.mtrx
# Number of sturgeon in each age class
Total=1000
Nj = Total*0.123
Nm = Total*0.359
Ns = Total*0.191
Ny = Total*0.173
Na = Total*0.154
N0 = Ny * (eggy*s0*spwn*p) + Na * (egga*s0*spwn*p)
Nt = c(N0,Nj,Nm,Ns,Ny,Na)
Nt
## What's the population estimate for next year?
trans.mtrx %*% Nt
# Simulation period
sim.years=1984:2011
# Model for simulation period
popn=NULL
for(year in 1:length(sim.years)){
Nt1= trans.mtrx %*% Nt
popn=c(popn,sum(Nt1, na.rm=T))
# reassign pop at time t1 to time t
Nt=Nt1
}
popn
length(sim.years)
require(popbio)
install.packages("popbio")
require(popbio)
sens<-eigen.analysis(trans.mtrx)
sens$lambda1
#' 4) calculate reproductive value for each stage
sens$repro.value
#' 4) calculate reproductive value for each stage
repro<-sens$repro.value
colnames(repro)<-c("Eggs","Juv","Marine","Sub","Young","Adult")
gamma.MOM<- function(meanz,sdz){
alpha<-(meanz/sdz)^2
beta<- (sdz^2)/meanz
return(c(alpha,beta)) }
daily.rate <- 0.2
## convert to annual
rate<-daily.rate*365
rate
growth<-gamma.MOM(yearly.rate,yearly.rate*0.1)
yearly.rate <- 73
growth<-gamma.MOM(yearly.rate,yearly.rate*0.1)
# Assume 10000 trees are currently 15 m tall.
trees<-rep(15,10000)
#####################################################################
##### simulate sizes after a month
trees2<-trees + rgamma(10000,growth[1],scale=growth[2])
######################################################################
### here's what we have
hist(trees2)
# Create 6 stages for height
siz.grps<-ifelse(trees2 < 70,1,ifelse(trees2 < 80,2,
ifelse(trees2 < 90,3,
ifelse(trees2 < 100,4,ifelse(trees2 < 110,5,6)))))
siz.grps
grp.tots<-as.data.frame(table(siz.grps))
grp.tots
aictable
# Set working directory here
setwd("C:/Users/bankh/My_Repos/habor-seal/data")
# Retrieve data
m.data<-read.csv("m.data.csv")
require(AICcmodavg) #for AICc
require(glmmTMB) # for glmm
require(DHARMa) # auto cor and zero-inflation
require(AICcmodavg) #for AICc
# Combine location avg noise and total seals within dates
new.w.data<-read.csv("new.w.data.csv")
# Fix date
new.w.data$date<-as.Date(as.character(new.w.data$date),format = "%m/%d/%Y")
m.data$date<-as.Date(as.character(m.data$date),format = "%m/%d/%Y")
new.w.data$j.date<- as.integer(new.w.data$j.date)
new.w.data$j.date<- ifelse(new.w.data$j.date == min(new.w.data$j.date),0, new.w.data$j.date-min(new.w.data$j.date))
m.data$j.date<- as.integer(m.data$j.date)
m.data$j.date<- ifelse(m.data$j.date == min(m.data$j.date),0, m.data$j.date-min(m.data$j.date))
new.w.data$year <-as.numeric(format(new.w.data$date, format = "%Y"))
m.data$year <-as.numeric(format(m.data$date, format = "%Y"))
# Add sample ID
new.w.data$id<- seq_along(new.w.data[,1])
m.data$id<- seq_along(m.data[,1])
# Merge data
full.data<-merge(new.w.data,m.data,all = T)
## Organize data by id
full.data<- full.data[order(full.data$id), ]
full.data$obs_id<- seq_along(full.data[,1])
full.data<- full.data[order(full.data$obs_id), ]
# Run glmmTMB
model0<- glmmTMB(seals ~ 1, data = full.data,
family = nbinom2, zi = ~ 1)
model1<- glmmTMB(seals ~ noise*site + tide + time + (1 | date) +
ar1(as.factor(month) + 0 | year), data = full.data,
family = nbinom2, zi = ~ 1)
model2<- glmmTMB(seals ~ noise*site +  (1 | date) + time +
ar1(as.factor(month) + 0 | year), data = full.data,
family = nbinom2, zi = ~ 1)
model3<- glmmTMB(seals ~ noise*site + (1 | date) +
ar1(as.factor(month) + 0 | year), data = full.data,
family = nbinom2, zi = ~ 1)
model4<- glmmTMB(seals ~ noise+site + (1 | date) +
ar1(as.factor(month) + 0 | year), data = full.data,
family = nbinom2, zi = ~ 1)
# Create list
models<-list(model0, model1, model2, model3, model4)
## Calculate AICc with glm of models
Modnames<- c("seals ~ 1",
"seals ~ site*noise + tide + time",
"seals ~ site*noise + time",
"seals ~ site*noise",
"seals ~ site+noise")
aictable<- aictab(models, modnames = Modnames,
second.ord = TRUE,
nobs = NULL, c.hat = 1) # Looks like site*noise are the best predictors
aictable
# Use model to predict the response variable
newdata <- data.frame(noise = mean(full.data$noise),
site = factor(1:2, levels = 1:2,
labels = unique(full.data$site)))
m3<- glm.nb(seals ~ site * noise, data = full.data)
require(MASS) # for glm
m3<- glm.nb(seals ~ site * noise, data = full.data)
newdata$phat <- predict.glm(m3, newdata, type = "response")
newdata
# Plot
newdata2 <- data.frame(
noise = rep(seq(from = min(full.data$noise), to = max(full.data$noise), length.out = 100), 2),
site = factor(rep(1:2, each = 100), levels = 1:2, labels =
unique(full.data$site)))
newdata2 <- cbind(newdata2, predict(m3, newdata2, type = "link", se.fit=TRUE))
newdata2 <- within(newdata2, {
seals <- exp(fit)
LL <- exp(fit - 1.96 * se.fit)
UL <- exp(fit + 1.96 * se.fit)
})
write.csv(newdata2, "newdata2.csv")
ggplot(newdata2, aes(noise, seals)) +
geom_ribbon(aes(ymin = LL, ymax = UL, fill = site), alpha = .25) +
geom_line(aes(colour = site), linewidth = 2) +
labs(x = "Noise Level (dB)", y = "Predicted Number of Seals Hauled-out")
# Load packages
require(ggplot2)
ggplot(newdata2, aes(noise, seals)) +
geom_ribbon(aes(ymin = LL, ymax = UL, fill = site), alpha = .25) +
geom_line(aes(colour = site), linewidth = 2) +
labs(x = "Noise Level (dB)", y = "Predicted Number of Seals Hauled-out")
# Set working directory here
setwd("C:/Users/bankh/My_Repos/habor-seal/data")
# Retrieve data
full.mdata<-read.csv("full.mdata.csv")
## Does the mean equal the variance?
var(full.mdata$seals)
mean(full.mdata$seals)
## Check if overdispersion is detected with full model
mod<- glm.nb(seals ~ noise + month + tide + time, data = full.mdata)
check_overdispersion(mod)
require(performance) # for overdispersion
check_overdispersion(mod)
## Check if overdispersion is detected with full model
mod<- glm.nb(seals ~ noise + month, data = full.mdata)
## Check if overdispersion is detected with full model
mod<- glm(seals ~ noise + month + tide + time, data = full.mdata, family = quasipoisson)
check_overdispersion(mod)
View(full.data)
## Check if overdispersion is detected with full model
fittedModel<- glmmTMB(seals[site=="marina"] ~ noise[site=="marina"] +
tide[site=="marina"] + time[site=="marina"] +
(1 | date[site=="marina"]) +
ar1(as.factor(j.date[site=="marina"]) + 0 | month[site=="marina"]),
data = full.data,
family = nbinom2, zi = ~ 1)
## Check if overdispersion is detected with full model
mod<- glm(seals ~ noise, data = full.mdata, family = quasipoisson)
check_overdispersion(mod)
### Check if data is zero inflated
testZeroInflation(simulationOutput)
m.mod3<- glm(seals ~ noise + month + time, data = full.mdata, family = quasipoisson)
summary(model3)
